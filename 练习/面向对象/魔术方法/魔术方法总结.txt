××× 特殊属性
a. python的名词空间指模块或作用域
b. import就是导入名词空间或叫导入模块的
c. 在类里看方法的第一位置参数是谁那就是谁的，如果是self，那么就会影响实例
如：def __dir__(self):，这会影响实例的dir
d. dir()用来收集模块的信息

××× hash
a. 用hash就是为了o1的时间复杂度，缓存的目的是再查，缓冲是为了匹配生产者与消费者的速度
b. hash冲突是两个对象在一个hash的计算空间中，可能算出的两个key是一样的
c. 可hash和去重是两个概念，可hash只是是否支持hash，能否给一个hash值。相等才会去重。仅用hash值不能验证两个实例是否相等。所以要用__eq__。
d. self.y == other.y叫二元操作符，self.y叫对象，==是操作符，相当于self.y对象在调用__eq__方法，而后面的other.y做为other参数。self.y是什么类型就调用什么类型的__eq__方法，而不是这里定义的__eq__方法，比如这里初始化时定义了self.y = 'y'，那么self.y就会调用字符串的__eq__方法。这里要看自己的逻辑，如果初始化定义了两个属性，这里可以判断一个属性相等就可以了，也可以判断两个属性相等才行，如return self.y == other.y and self.x == other.x

××× eq
a == b 相当于 a.__equal__(b)。这就是二元操作符如何等价到一个方法，b就是__eq__(self, other)中的other，a就是self

××× bool
先找对象方法中是否定义了bool，如果没有再看是否有len，如果都没有定义，返回True。如果定义了，方法返回什么就返回什么 ，容器内一般都不实现bool方法，而用len方法

××× 可视化
内建的几个函数，它直接作用在对象上，这样就会调用对象的str。如果并不直接作用在元素或对象上，就会调用它的repr方法。所以可以将repr和str的返回值写成一样的

××× 运算符重载
a. 运算符重载可以提高类的可用性
b. 需要看一下初始化时的self.x = x，个人感觉这就表示实例就是x，如果还有self.y = y，那么self就是x,y。所以返回self时要注意应该返回什么
c.


容器
1. 可以在初始化时自定义self.items = []，这样就定义了一个列表，之后用self.items就可以打印整个列表，self.items.append()可以向列表中添加内容。

上下文管理
1. 当一个对象同时实现了`__enter__()`和`__exit__()`方法，它就属于上下文管理的对象
2. 实例化对象的时候，并不会调用`enter`，进入`with`语句块应用`__enter__`方法，然后执行语句体，最后离开`with`语句块的时候，调用`__exit__`方法。`with`可以开启一个上下文运行环境，在执行前做一些准备工作，执行后做一些收尾工作。
3. 遇到异常时，`enter`和`exit`照样执行，上下文管理是安全的。在执行完'exit'后才会抛出异常。即使使用了sys.exit()方法，依然执行了__exit__方法后才退出python运行环境。这说明上下文管理很安全
4. `__enter__`方法返回值就是上下文中使用的对象，`with`语法会把它的返回值赋给`as`子句的变量。
5. `__exit__`方法有3个参数：
`__exit__(self, exc_type, exc_value, traceback)`
这三个参数都与异常有关。
如果该上下文退出时没有异常，这3个参数都为None。
如果有异常，参数意义如下
`exc_type`，异常类型
`exc_value`，异常的值
`traceback`，异常的追踪信息
`__exit__`方法返回一个等效True的值，则压制异常；否则，继续抛出异常

6. 上下文应用场景
增强功能: 在代码执行的前后增加代码，以增强其功能。类似装饰器的功能。
资源管理: 打开了资源需要关闭，例如文件对象、网络连接、数据库连接等
权限验证: 在执行代码之前，做权限的验证，在`__enter__`中处理